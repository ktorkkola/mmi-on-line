
function W = lda(X, J, od)
%
% W = lda(X, J, od)
%
% X  - input data as column vectors, each class after one another
% J  - each row is start and stop indices for a class in X (yeah, some  
%      redundant information, but it fits my other data structures) 
% od - desired output space dimension
% W  - returns the basis vectors as rows
%
% Linear Discriminant Analysis: Finds the linear transformation 
% that maximizes class separability measured by maximizing 
% tr( inv(Sw)*Sb ) where Sw is the within-class scatter matrix
% and Sb is between class scatter matrix *OR* ...
% by minimizing tr( inv(Sm)*Sw ) where Sm=Sb+Sw.

% rev 1.00, 991112, Kari Torkkola,
% rev 1.5,  000315, if od > number of classes, returns anyway od directions,
%                   extra ones are random.
% rev 1.6,  010206, replaced inverse with matrix division operator
% rev 1.7,  010212, inv(Sw)*Sb sometimes produces an error with bad conditioning
%                   Added inv(Sm)*Sw as an alternative criterion
% rev 1.8,  010419, if requested more vectors than original data dim, don't orthogonalize
% rev 1.9,  010503, extra random vectors are small and generated by randn

[d,Ntot] = size(X);		
N = J(:,2)-J(:,1)+1;	% How many items in each class
Nc = length(N);		% Number of classes

Sw = zeros(d,d);  % within-class scatter matrix
Sb = zeros(d,d);  % between-class scatter matrix
M0 = mean(X');    % mean of all data
for i=1:Nc
   datai = X(:,J(i,1):J(i,2))'; % data for class i as row vectors
   Sw = Sw + (N(i)/Ntot)*cov(datai); % sum of class covariances weighted by class probs
   M = mean(datai); % class mean
   Sb = Sb + (N(i)/Ntot)*(M-M0)'*(M-M0); 
end

% this didn't work really well
%if cSw > (1/eps)
%   criterion = Sb;
%   disp(sprintf('Lda warning, bad Sw cond %g, Using only Sb',cSw));
%else
%   criterion = Sw \ Sb;
%end


 
options.disp=0;
try       % first inv(Sw)*Sb
   criterion = Sw \ Sb;
   disp(sprintf('Sw cond %g, Sb cond %g, criterion cond %g',cond(Sw),cond(Sb),cond(criterion)));
   r = rank(criterion);
   if r<od howmany = r; else howmany = od; end;
   % compute the desired number of eigenvectors corresponding to largest eigenvalues
   [vectorsLDA,eigsLDA]=eigs( criterion, howmany, 'lm', options);% this goes with Sw\Sb
catch     % if that does not work, then inv(Sm)*Sw
   disp(' inv(Sw)*Sb criterion failed, trying inv(Sm)*Sw.');
   Sm = Sw+Sb;
   criterion = Sm \ Sw;
   disp(sprintf('Sm cond %g, criterion cond %g',cond(Sm),cond(criterion) ));
   howmany = od;
   % compute the desired number of eigenvectors corresponding to smallest eigenvalues
   [vectorsLDA,eigsLDA]=eigs( criterion, howmany, 'sm', options); % this goes with Sm\Sw
end

if howmany<od
   vectorsLDA = [vectorsLDA randn(d, od-howmany)/( 2 * sqrt(d+1) ) ]; % scale random part
   if od<=d % if requested less than original dim we can orthogonalize
      vectorsLDA = orth(vectorsLDA);
   end
end

W=vectorsLDA'; % now rows of W are the directions

% visualize the criterion matrix
% figure; imagesc(criterion); colormap hot;
